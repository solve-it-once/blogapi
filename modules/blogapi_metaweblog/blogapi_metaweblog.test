<?php

/**
 * @file
 * Endpoint tests for BlogAPI Metaweblog
 */
class BlogapiMetaweblogEndpointTestCase extends DrupalWebTestCase {
  protected $profile = 'testing';
  protected $blogID = 'article';
  protected $privilegedUser;
  protected $testfile;
  protected $privilegedUser2;
  protected $xmlrpcUrl;

  /**
   * Test info.
   */
  public static function getInfo() {
    return array(
      'name' => t('Metaweblog Endpoint Tests'),
      'description' => t('Run tests for Metaweblog endpoints') ,
      'group' => t('BlogAPI'),
    );
  }

  /**
   * Set up test.
   */
  public function setUp() {
    parent::setUp(array(
      'blogapi',
      'blogapi_metaweblog',
      'filter',
      'services',
      'taxonomy',
      'xmlrpc_server',
    ));

    // Get the URL of the XML-RPC endpoint.
    $this->xmlrpcUrl = url('blogapi/xmlrpc', array('absolute' => TRUE));

    // Create a user with appropriate permissions.
    $this->privilegedUser = $this->drupalCreateUser(array('manage content with blogapi'));
    $this->privilegedUser->mail = 'test@example.com';
    $this->privilegedUser->name = 'Test user';
    user_save($this->privilegedUser);

    // Create another user with more permissions.
    $this->privilegedUser2 = $this->drupalCreateUser(array('administer nodes', 'manage content with blogapi', 'bypass node access'));
    $this->privilegedUser2->mail = 'test@example.com';
    $this->privilegedUser2->name = 'Test user2';
    user_save($this->privilegedUser2);

    $this->drupalCreateContentType(array('type' => 'article'));
  }

  /**
   * Test metaWeblog.newPost().
   */
  public function testNewPost() {
    $post_title = user_password(20);
    $post_body = user_password(20);
    $nid = $this->createPostViaxmlrpc($post_title, $post_body);


    $this->assertTrue(!empty($nid), 'Node ID was returned');

    $node = node_load($nid);

    $this->assertTrue(is_object($node), 'Node was created');

    $this->assertTrue($node->title == $post_title, 'Title is the same');

    $this->assertTrue(!empty($node->body[LANGUAGE_NONE][0]['value']) && $node->body[LANGUAGE_NONE][0]['value'] == $post_body, 'Body is the same');

    $this->assertTrue($node->status == 1, 'Node is published');
  }

  /**
   * Test metaWeblog.editPost().
   */
  public function testEditPost() {
    $post_title = user_password(20);
    $post_body = user_password(20);
    $nid = $this->createPostViaxmlrpc($post_title, $post_body);
    $old_node = node_load($nid);
    debug($old_node);

    $post_title .= ' modified title';
    $post_body .= ' modified body';

    $result = xmlrpc($this->xmlrpcUrl, array(
      'metaWeblog.editPost' => array(
        $nid,
        $this->privilegedUser2->name,
        $this->privilegedUser2->pass_raw,
        array(
          'title' => $post_title,
          'description' => $post_body,
        ),
        0
      )
    ));

    $new_node = node_load($nid, NULL, TRUE);
    debug($new_node);
    $this->assertTrue($result && $new_node->title != $old_node->title, 'Node was updated');

    $this->assertTrue($new_node->title == $post_title, 'Title was updated');

    $this->assertTrue(!empty($new_node->body[LANGUAGE_NONE][0]['value']) && $new_node->body[LANGUAGE_NONE][0]['value'] == $post_body, 'Body was updated');

    $this->assertTrue($new_node->status == 0, 'Node was unpublished');
  }

  /**
   * Test metaWeblog.getPost().
   */
  public function testGetPost() {
    $post_title = user_password(20);
    $post_body = user_password(20);
    $nid = $this->createPostViaxmlrpc($post_title, $post_body);

    $node = node_load($nid);

    $post = xmlrpc($this->xmlrpcUrl, array(
      'metaWeblog.getPost' => array(
        $nid,
        $this->privilegedUser2->name,
        $this->privilegedUser2->pass_raw,
      )
    ));

    $xmlrpcval = array(
      'userid' => $node->name,
      'dateCreated' => xmlrpc_date($node->created),
      'title' => $node->title,
      'postid' => $node->nid,
      'link' => url('node/' . $node->nid, array('absolute' => TRUE)),
      'permaLink' => url('node/' . $node->nid, array('absolute' => TRUE)),
    );

    $this->assertTrue($post['userid'] == $this->privilegedUser2->name, 'Author name is correct');
    $this->assertTrue($post['dateCreated'] == xmlrpc_date($node->created), 'Created date is correct');
    $this->assertTrue($post['title'] == $node->title, 'Post title is correct');
    $this->assertTrue($post['postid'] == $node->nid, 'Post ID is correct');
    $node_body = !empty($node->body[LANGUAGE_NONE][0]['value']) ? $node->body[LANGUAGE_NONE][0]['value'] : '';
    $this->assertTrue($post['content'] == '<title>' . $node->title . '</title>' . $node_body, 'Post content is correct');
    $this->assertTrue($post['link'] == url('node/' . $node->nid, array('absolute' => TRUE)), 'Post link is correct');
  }

  /**
   * Test metaWeblog.newMediaObject().
   */
  public function testNewMediaObject() {
    $this->testfiles = $this->drupalGetTestFiles('image');
    $this->testfile = current($this->testfiles);

    $result = xmlrpc($this->xmlrpcUrl, array(
      'metaWeblog.newMediaObject' => array(
        $this->blogID,
        $this->privilegedUser2->name,
        $this->privilegedUser2->pass_raw,
        array(
          'name' => $this->testfile->filename,
          'type' => mime_content_type(file_create_url($this->testfile->uri)),
          'bits' => base64_encode(file_get_contents(file_create_url($this->testfile->uri))),
        ),
      )
    ));
    $this->assert('pass', '' . xmlrpc_error_msg());

    debug(json_encode($this->testfile));
    debug(json_encode($result));
    $this->assertTrue(is_file($result['url']), 'New file saved to disk.', 'FileResource: Create');
  }

  /**
   * Test metaWeblog.getCategories().
   */
  public function testGetCategories() {
    $this->admin_user = $this->drupalCreateUser(array('administer taxonomy', 'bypass node access', 'administer services'));
    $this->drupalLogin($this->admin_user);
    $this->vocabulary = $this->createVocabulary();

    $field = array(
      'field_name' => 'taxonomy_' . $this->vocabulary->machine_name,
      'type' => 'taxonomy_term_reference',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => $this->vocabulary->machine_name,
            'parent' => 0,
          ),
        ),
      ),
    );

    field_create_field($field);

    $this->instance = array(
      'field_name' => 'taxonomy_' . $this->vocabulary->machine_name,
      'bundle' => 'article',
      'entity_type' => 'node',
      'widget' => array(
        'type' => 'options_select',
      ),
      'display' => array(
        'default' => array(
          'type' => 'taxonomy_term_reference_link',
        ),
      ),
    );

    field_create_instance($this->instance);

    $terms = array();

    for ($i = 0; $i < 5; $i++) {
      $terms[] = $this->createTerm($this->vocabulary);
    }

    $testNode = array(
      'type' => 'article',
      $field['field_name'] => array(
        LANGUAGE_NONE => array(
          array(
            'tid' => $terms[0]->tid
          )
        )
      )
    );

    $node = $this->drupalCreateNode($testNode);

    $results = xmlrpc($this->xmlrpcUrl, array(
      'metaWeblog.getCategories' => array(
        $this->blogID,
        $this->privilegedUser2->name,
        $this->privilegedUser2->pass_raw,
      )
    ));

    $this->assertTrue(is_array($results) && count($results) == count($terms), 'Service returned correct terms number');

    $success = TRUE;

    foreach ($results as $category) {
      $term = taxonomy_term_load($category['categoryId']);
      if (empty($term) || $term->name != $category['categoryName']) {
        $success = FALSE;
      }
    }

    $this->assertTrue($success, 'All terms were retrieved properly');
  }

  /**
   * test metaWeblog.getRecentPosts().
   */
  public function testGetRecentPosts() {
    $default_title = 'Default title ';
    $default_body = 'Default body ';

    for ($i = 0; $i < 11; $i++) {
      $this->createPostViaxmlrpc($default_title . $i, $default_body . $i);
    }

    $posts_count = 9;

    $results = xmlrpc($this->xmlrpcUrl, array(
      'metaWeblog.getRecentPosts' => array(
        $this->blogID,
        $this->privilegedUser2->name,
        $this->privilegedUser2->pass_raw,
        $posts_count,
      )
    ));

    $this->assertTrue(is_array($results) && count($results) == $posts_count, 'Service returned correct posts number');
    $success = TRUE;

    foreach ($results as $post) {
      $node = node_load($post['postid']);

      if (empty($node) || $node->title != $post['title']
        || (!empty($node->body[LANGUAGE_NONE][0]['value']) && $node->body[LANGUAGE_NONE][0]['value'] != $post['description'])) {
        $success = FALSE;
      }
    }

    $this->assertTrue($success, 'All nodes were retrieved properly');
  }

  protected function createPostViaxmlrpc($title, $body, $status = 1) {
    return xmlrpc($this->xmlrpcUrl, array(
      'metaWeblog.newPost' => array(
        $this->blogID,
        $this->privilegedUser2->name,
        $this->privilegedUser2->pass_raw,
        array(
          'title' => $title,
          'description' => $body,
        ),
        $status
      )
    ));
  }

  /**
   * Returns a new vocabulary with random properties.
   */
  function createVocabulary() {
    // Create a vocabulary.
    $vocabulary = new stdClass();
    $vocabulary->name = $this->randomName();
    $vocabulary->description = $this->randomName();
    $vocabulary->machine_name = drupal_strtolower($this->randomName());
    $vocabulary->help = '';
    $vocabulary->nodes = array('article' => 'article');
    $vocabulary->weight = mt_rand(0, 10);
    taxonomy_vocabulary_save($vocabulary);

    return $vocabulary;
  }

  /**
   * Returns a new term with random properties in vocabulary $vid.
   */
  function createTerm($vocabulary) {
    $term = new stdClass();
    $term->name = $this->randomName();
    $term->description = $this->randomName();
    // Use the first available text format.
    $term->format = db_query_range('SELECT format FROM {filter_format}', 0, 1)->fetchField();
    $term->vid = $vocabulary->vid;
    taxonomy_term_save($term);
    return $term;
  }
}
