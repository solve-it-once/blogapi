<?php

/**
 * @file
 * Provides MetaWeblog services for BlogAPI
 */

/**
 * Implements hook_blogapi_info().
 */
function blogapi_metaweblog_blogapi_info() {
  return array(
    'api_version' => 2,
    'type' => 'xmlrpc',
    'name' => 'MetaWeblog',
    'provides_file_handling' => TRUE,
  );
}

/**
 * Implements hook_ctools_plugin_api().
 */
function blogapi_metaweblog_ctools_plugin_api() {
  list($module, $api) = func_get_args();
  if ($module == "services" && $api == "services") {
    return array("version" => "3");
  }
}

/**
 * Implements hook_services_resources().
 */
function blogapi_metaweblog_services_resources() {
  return array(
    'metaWeblog' => array(
      'actions' => array(
        'newPost' => array(
          'access callback' => 'services_access_menu',
          'callback' => 'blogapi_metaweblog_new_post',
          'enabled' => 1,
          'help' => 'Creates a new post, and optionally publishes it.',
          'args' => array(
            array(
              'name' => 'blogid',
              'type' => 'string',
              'description' => 'blogid',
              'source' => array('data' => 'blogid'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'username',
              'type' => 'string',
              'description' => 'A valid username',
              'source' => array('data' => 'username'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'password',
              'type' => 'string',
              'description' => 'A valid password',
              'source' => array('data' => 'password'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'content',
              'type' => 'array',
              'description' => 'content',
              'source' => array('data' => 'content'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'publish',
              'type' => 'boolean',
              'description' => 'publish',
              'source' => array('data' => 'publish'),
              'optional' => FALSE,
            ),
          ),
        ),
        'editPost' => array(
          'access callback' => 'services_access_menu',
          'callback' => 'blogapi_metaweblog_edit_post',
          'enabled' => 1,
          'help' => 'Updates information about an existing post.',
          'args' => array(
            array(
              'name' => 'postid',
              'type' => 'int',
              'description' => 'postid',
              'source' => array('data' => 'postid'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'username',
              'type' => 'string',
              'description' => 'A valid username',
              'source' => array('data' => 'username'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'password',
              'type' => 'string',
              'description' => 'A valid password',
              'source' => array('data' => 'password'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'content',
              'type' => 'array',
              'description' => 'content',
              'source' => array('data' => 'content'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'publish',
              'type' => 'boolean',
              'description' => 'publish',
              'source' => array('data' => 'publish'),
              'optional' => FALSE,
            ),
          ),
        ),
        'getPost' => array(
          'access callback' => 'services_access_menu',
          'callback' => 'blogapi_metaweblog_get_post',
          'enabled' => 1,
          'help' => 'Returns information about a specific post.',
          'args' => array(
            array(
              'name' => 'postid',
              'type' => 'int',
              'description' => 'postid',
              'source' => array('data' => 'postid'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'username',
              'type' => 'string',
              'description' => 'A valid username',
              'source' => array('data' => 'username'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'password',
              'type' => 'string',
              'description' => 'A valid password',
              'source' => array('data' => 'password'),
              'optional' => FALSE,
            ),
          ),
        ),
        'newMediaObject' => array(
          'access callback' => 'services_access_menu',
          'callback' => 'blogapi_metaweblog_new_media_object',
          'enabled' => 1,
          'help' => 'Uploads a file to your webserver.',
          'args' => array(
            array(
              'name' => 'blogid',
              'type' => 'string',
              'description' => 'blogid',
              'source' => array('data' => 'blogid'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'username',
              'type' => 'string',
              'description' => 'A valid username',
              'source' => array('data' => 'username'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'password',
              'type' => 'string',
              'description' => 'A valid password',
              'source' => array('data' => 'password'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'file',
              'type' => 'array',
              'description' => 'file',
              'source' => array('data' => 'file'),
              'optional' => FALSE,
            ),
          ),
        ),
        'getCategories' => array(
          'access callback' => 'services_access_menu',
          'callback' => 'blogapi_metaweblog_get_categories',
          'enabled' => 1,
          'help' => 'Returns a list of all categories to which the post is assigned.',
          'args' => array(
            array(
              'name' => 'blogid',
              'type' => 'string',
              'description' => 'blogid',
              'source' => array('data' => 'blogid'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'username',
              'type' => 'string',
              'description' => 'A valid username',
              'source' => array('data' => 'username'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'password',
              'type' => 'string',
              'description' => 'A valid password',
              'source' => array('data' => 'password'),
              'optional' => FALSE,
            ),
          ),
        ),
        'getRecentPosts' => array(
          'access callback' => 'services_access_menu',
          'callback' => 'blogapi_metaweblog_get_recent_posts',
          'enabled' => 1,
          'help' => 'Returns a list of the most recent posts in the system.',
          'args' => array(
            array(
              'name' => 'blogid',
              'type' => 'string',
              'description' => 'blogid',
              'source' => array('data' => 'blogid'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'username',
              'type' => 'string',
              'description' => 'A valid username',
              'source' => array('data' => 'username'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'password',
              'type' => 'string',
              'description' => 'A valid password',
              'source' => array('data' => 'password'),
              'optional' => FALSE,
            ),
            array(
              'name' => 'postid',
              'type' => 'int',
              'description' => 'postid',
              'source' => array('data' => 'postid'),
              'optional' => FALSE,
            ),
          ),
        ),
      ),
    ),
  );
}

/**
 * Service callback for metaWeblog.newPost
 */
function blogapi_metaweblog_new_post($blogid, $username, $password, $content, $publish) {
  $postdata = array(
    'type' => $blogid,
    'status' => $publish,
    'title' => $content['title'],
    'body' => $content['description'],
  );

  if (module_exists('comment') && array_key_exists('mt_allow_comments', $content)) {
    switch ($content['mt_allow_comments']) {
      case 0:
        $postdata['comment'] = COMMENT_NODE_HIDDEN;
        break;
      case 1:
        $postdata['comment'] = COMMENT_NODE_OPEN;
        break;
      case 2:
        $postdata['comment'] = COMMENT_NODE_CLOSED;
        break;
    }
  }

  $body = $postdata['body'];
  if (isset($content['mt_excerpt'])) {
    $body = $content['mt_excerpt'] . '<!--break-->' . $body;
  }
  if (isset($content['mt_text_more'])) {
    $body = $body . '<!--extended-->' . $content['mt_text_more'];
  }

  $node_id = blogapi_new_post($username, $password, $postdata);

  if (is_numeric($node_id)) {
    // If this operation is successful, we're supposed to return a string from
    // metaweblog.newPost.
    return (string)$node_id;
  }
  else {
    // Otherwise, there is a problem, so just pass through what we got back from
    // blogapi_new_post().
    return $node_id;
  }
}


/**
 * Service allback for metaWeblog.editPost
 */
function blogapi_metaweblog_edit_post($postid, $username, $password, $content, $publish) {
  // Validate the user.
  $user = blogapi_validate_user($username, $password);

  $old_node = node_load($postid);
  $new_node = new stdClass;

  if (!$old_node) {
    return services_error(t('Node @nid not found', array('@nid' => $postid)), 404);
  }
  // Let the teaser be re-generated.
  unset($old_node->teaser);

  if (!node_access('update', $old_node, $user)) {
    return services_error(t('You do not have permission to update this post.'), 403);
  }

  // Save the original status for validation of permissions.

  $new_node->status = $publish;

  $new_node->title = $content['title'];
  $new_node->body[LANGUAGE_NONE][0]['value'] = $content['description'];

  if (empty($content['date']) && user_access('administer nodes')) {
    $new_node->date = format_date($old_node->created, 'custom', 'Y-m-d H:i:s O');
  }

  _blogapi_mt_extra($new_node, $content);

  module_invoke_all('blogapi_node_edit', $new_node);

  blogapi_status_error_check($new_node);

  // Load the required includes for drupal_execute
  module_load_include('inc', 'node', 'node.pages');

  $node_type = $old_node['type'];
  node_object_prepare($new_node);

  // Setup form_state.
  $form_state = array();
  $form_state['values'] = $new_node;
  $form_state['values']['op'] = t('Save');
  $form_state['node'] = $old_node;
  drupal_form_submit($node_type . '_node_form', $form_state, $old_node);

  if ($errors = form_get_errors()) {
    return services_error(implode(" ", $errors), 406, array('form_errors' => $errors));
  }
  else {
    watchdog('content', '@type: updated %title using Blog API.', array('@type' => $old_node->type, '%title' => $new_node->title), WATCHDOG_NOTICE, l(t('view'), "node/$old_node->nid"));
    return TRUE;
  }
}

/**
 * Service callback for metaWeblog.getPost
 */
function blogapi_metaweblog_get_post($postid, $username, $password) {
  // Validate the user.
  $user = blogapi_validate_user($username, $password);

  $node = node_load($postid);
  if (!node_access('view', $node, $user) || !user_access('administer nodes')) {
    // User does not have permission to view the node.
    return services_error(t('You are not authorized to view post @postid', array('@postid' => $postid)), 403);
  }

  return blogapi_format_post_for_xmlrpc($node, TRUE);
}

/**
 * Service callback for metaWeblog.newMediaObject
 */
function blogapi_metaweblog_new_media_object($blogid, $username, $password, $file) {
  // Validate the user.
  $user = blogapi_validate_user($username, $password);

  $extensions = '';
  $usersize = 0;
  $uploadsize = 0;

  $roles = array_intersect(user_roles(FALSE, 'manage content with blogapi'), $user->roles);

  foreach ($roles as $rid => $name) {
    $extensions .= ' ' . strtolower(variable_get("blogapi_extensions_$rid", variable_get('blogapi_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp')));
    $usersize = max($usersize, variable_get("blogapi_usersize_$rid", variable_get('blogapi_usersize_default', 1)) * 1024 * 1024);
    $uploadsize = max($uploadsize, variable_get("blogapi_uploadsize_$rid", variable_get('blogapi_uploadsize_default', 1)) * 1024 * 1024);
  }

  $filesize = strlen($file['bits']);

  if ($filesize > $uploadsize) {
    return services_error(t('It is not possible to upload the file, because it exceeded the maximum filesize of @maxsize.', array('@maxsize' => format_size($uploadsize))), 413);
  }

  if (blogapi_space_used($user->uid) + $filesize > $usersize) {
    return services_error(t('The file can not be attached to this post, because the disk quota of @quota has been reached.', array('@quota' => format_size($usersize))), 413);
  }

  // Only allow files with whitelisted extensions and convert remaining dots to
  // underscores to prevent attacks via non-terminal executable extensions with
  // files such as exploit.php.jpg.
  $whitelist = array_unique(explode(' ', trim($extensions)));

  $name = basename($file['name']);

  if ($extension_position = strrpos($name, '.')) {
    $filename = drupal_substr($name, 0, $extension_position);
    $final_extension = drupal_substr($name, $extension_position + 1);

    if (!in_array(strtolower($final_extension), $whitelist)) {
      return services_error(t('It is not possible to upload the file, because it is only possible to upload files with the following extensions: @extensions', array('@extensions' => implode(' ', $whitelist))), 403);
    }

    $filename = str_replace('.', '_', $filename);
    $filename .= '.' . $final_extension;
  }

  else {
    $filename = $name;
  }
  $uri = file_build_uri($filename);
  $data = $file['bits'];

  if (!$data) {
    return services_error(t('No file sent.'), 400);
  }

  if (!$file = file_save_data($data, $uri)) {
    return services_error(t('Error storing file.'), 500);
  }

  // Store Drupal file ID in separate dfid column and unset fid to use own blogapi serial value
  $file->dfid = $file->fid;
  unset($file->fid);

  drupal_write_record('blogapi_files', $file);

  // Return the successful result.
  return array('url' => file_create_url($file->uri), 'struct');
}

/**
 * Service callback for metaWeblog.getCategories
 */
function blogapi_metaweblog_get_categories($blogid, $username, $password) {
  // Validate the user.
  $user = blogapi_validate_user($username, $password);

  if (($error = blogapi_validate_content_type($blogid)) !== TRUE) {
    // Return an error if not configured type.
    return services_error($error['message'], $error['error_code']);
  }

  $vocabularies = module_invoke('taxonomy', 'get_vocabularies', $blogid, 'vid');
  $categories = array();
  if ($vocabularies) {
    foreach ($vocabularies as $vocabulary) {
      $terms = module_invoke('taxonomy', 'get_tree', $vocabulary->vid);
      foreach ($terms as $term) {
        $term_name = $term->name;
        foreach (module_invoke('taxonomy', 'get_parents', $term->tid, 'tid') as $parent) {
          $term_name = $parent->name . '/' . $term_name;
        }
        $categories[] = array('categoryName' => $term_name, 'categoryId' => $term->tid);
      }
    }
  }

  return $categories;
}

/**
 * Service callback for metaWeblog.getRecentPosts
 */
function blogapi_metaweblog_get_recent_posts($blogid, $username, $password, $number_of_posts) {
  // Validate the user.
  $user = blogapi_validate_user($username, $password);

  // Validate the content type.
  $error = blogapi_validate_content_type($blogid);

  if ($error !== TRUE) {
    // Return an error if the content type is not configured for use
    // with BlogAPI.
    return services_error($error['message'], $error['error_code']);
  }

  // Get posts.
  $blogs = blogapi_get_recent_posts($blogid, $user, $number_of_posts);

  $posts = array();
  foreach ($blogs as $blog) {
    $posts[] = blogapi_format_post_for_xmlrpc($blog, TRUE);
  }

  return $posts;
}
