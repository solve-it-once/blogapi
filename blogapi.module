<?php
/**
 * @file
 * Enable users to post using applications that support BlogAPIs.
 */

/**
 * Implements hook_permission().
 */
function blogapi_permission() {
  return array(
    'manage content with blogapi' => array(
      'title' => t('Manage content with BlogAPI'),
    ),
    'administer blogapi' => array(
      'title' => t('Administer BlogAPI settings'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function blogapi_menu() {
  $items = array();

  $items['blogapi/rsd'] = array(
    'title' => 'RSD',
    'page callback' => 'blogapi_rsd',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/services/blogapi'] = array(
    'title' => 'Blog API',
    'description' => 'Configure content types and file settings for external blogging clients.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('blogapi_admin_settings_form'),
    'access arguments' => array('administer blogapi'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Implement hook_init().
 */
function blogapi_init() {
  if (drupal_is_front_page()) {
    drupal_add_html_head_link(
      array(
        'rel' => 'EditURI',
        'type' => 'application/rsd+xml',
        'title' => t('RSD'),
        'href' => url('blogapi/rsd', array('absolute' => TRUE))
      ),
      TRUE
    );
  }
}

/**
 * Ensure that a given user has permission to use BlogAPI
 */
function blogapi_validate_user($username, $password) {
  global $user;

  // Check the username and password
  $tmpuid = user_authenticate($username, $password);

  if ($tmpuid !== FALSE) {
    // Username and password match up, now check permissions.
    $tmpuser = user_load_by_name($username);

    if (user_access('manage content with blogapi', $tmpuser)) {
      // User has appropriate permissions
      $user = $tmpuser;
      return $user;
    }
    else {
      return t('You do not have permission to edit this blog.');
    }
  }
  else {
    return t('Invalid username or password');
  }
}

/**
 * Return a BlogAPI RSD for XML-RPC APIs
 *
 * @todo: Implement apiLink correctly using service endpoint URL
 * @todo: Implement multi-user blogs
 */
function blogapi_rsd() {
  global $base_url;

  $base = url('', array('absolute' => TRUE));
  $xmlrpc_apis = blogapi_get_info('xmlrpc');
  $default_xmlrpc_api = variable_get('blogapi_xmlrpc_default_provider', NULL);
  $blogid = 1; # until we figure out how to handle multiple bloggers

  drupal_add_http_header('Content-Type', 'application/rsd+xml; charset=utf-8');

  // The extra whitespace in this function is to preserve code alignment in the output.
  print <<<__RSD__
<?xml version="1.0"?>
<rsd version="1.0" xmlns="http://archipelago.phrasewise.com/rsd">
  <service>
    <engineName>Drupal</engineName>
    <engineLink>http://drupal.org/</engineLink>
    <homePageLink>{$base}</homePageLink>
    <apis>
__RSD__;

  foreach($xmlrpc_apis as $module => $info) {
    $default = 'false';
    if ($module == $default_xmlrpc_api) {
      $default = 'true';
    }
    $endpoint = $base_url . '/' . 'blogapi' . '/' . $info['type'];
    print "\n      <api name='{$info['name']}' preferred='{$default}' apiLink='{$endpoint}' blogID='{$blogid}' />";
  }

  print <<<__RSD__

    </apis>
  </service>
</rsd>

__RSD__;

}

/**
 * BlogAPI admin settings form
 */
function blogapi_admin_settings_form() {
  $form = array();

  $form['settings_apis'] = array(
    '#type' => 'fieldset',
    '#title' => t('API Configuration'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );

  // Default provider for each API
  foreach(blogapi_get_api_types() as $type) {
    $providers = blogapi_get_info($type);
    $provider_options = array();
    foreach ($providers as $name => $provider) {
      $provider_options[$name] = $provider['name'];
    }

    $form['settings_apis']['blogapi_' . $type . '_default_provider'] = array(
      '#type' => 'radios',
      '#title' => t('Default provider for %type APIs', array('%type' => $type)),
      '#required' => TRUE,
      '#options' => $provider_options,
      '#default_value' => variable_get('blogapi_' . $type . '_default_provider', NULL),
      '#description' => t('Select the default provider for %type API clients. This may affect client configuration.', array('%type' => $type)),
    );
  }

  $form['settings_node_types'] = array(
    '#type' => 'fieldset',
    '#title' => t('Node Types'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );

  // Set up BlogAPI node types
  $node_types = array_map('check_plain', node_type_get_names());
  $defaults = isset($node_types['article']) ? array('article' => 'article'): array();
  $form['settings_node_types']['blogapi_node_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Enable for external blogging clients'),
    '#required' => TRUE,
    '#default_value' => variable_get('blogapi_node_types', $defaults),
    '#options' => $node_types,
    '#description' => t('Select the content types available to external blogging clients via Blog API. If supported, each enabled content type will be displayed as a separate "blog" by the external client.')
  );

  $form['settings_files'] = array(
    '#type' => 'fieldset',
    '#title' => t('File Settings'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );

  $blogapi_extensions_default = variable_get('blogapi_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp');
  $blogapi_uploadsize_default = variable_get('blogapi_uploadsize_default', 1);
  $blogapi_usersize_default = variable_get('blogapi_usersize_default', 1);

  $form['settings_files']['blogapi_extensions_default'] = array(
    '#type' => 'textfield',
    '#title' => t('Default permitted file extensions'),
    '#default_value' => $blogapi_extensions_default,
    '#maxlength' => 255,
    '#description' => t('Default extensions that users can upload. Separate extensions with a space and do not include the leading dot.'),
  );

  $form['settings_files']['blogapi_uploadsize_default'] = array(
    '#type' => 'textfield',
    '#title' => t('Default maximum file size per upload'),
    '#default_value' => $blogapi_uploadsize_default,
    '#size' => 5,
    '#maxlength' => 5,
    '#description' => t('The default maximum file size a user can upload.'),
    '#field_suffix' => t('MB'),
  );

  $form['settings_files']['blogapi_usersize_default'] = array(
    '#type' => 'textfield',
    '#title' => t('Default total file size per user'),
    '#default_value' => $blogapi_usersize_default,
    '#size' => 5,
    '#maxlength' => 5,
    '#description' => t('The default maximum size of all files a user can have on the site.'),
    '#field_suffix' => t('MB'),
  );

  $form['settings_files']['upload_max_size'] = array(
    '#value' => '<p>' . t('Your PHP settings limit the maximum file size per upload to %size.', array('%size' => format_size(file_upload_max_size()))) . '</p>'
  );

  $roles = user_roles(FALSE, 'manage content with blogapi');
  foreach ($roles as $rid => $role) {
    $form['settings_files']['settings_role_' . $rid] = array(
      '#type' => 'fieldset',
      '#title' => t('Settings for @role role', array('@role' => $role)),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    $form['settings_files']['settings_role_' . $rid]['blogapi_extensions_' . $rid] = array(
      '#type' => 'textfield',
      '#title' => t('Permitted file extensions'),
      '#default_value' => variable_get('blogapi_extensions_' . $rid, $blogapi_extensions_default),
      '#maxlength' => 255,
      '#description' => t('Extensions that users in this role can upload. Separate extensions with a space and do not include the leading dot.'),
    );
    $form['settings_files']['settings_role_' . $rid]['blogapi_uploadsize_' . $rid] = array(
      '#type' => 'textfield',
      '#title' => t('Maximum file size per upload'),
      '#default_value' => variable_get('blogapi_uploadsize_' . $rid, $blogapi_uploadsize_default),
      '#size' => 5,
      '#maxlength' => 5,
      '#description' => t('The maximum size of a file a user can upload (in megabytes).'),
      '#field_suffix' => t('MB'),
    );
    $form['settings_files']['settings_role_' . $rid]['blogapi_usersize_' . $rid] = array(
      '#type' => 'textfield',
      '#title' => t('Total file size per user'),
      '#default_value' => variable_get('blogapi_usersize_' . $rid, $blogapi_usersize_default),
      '#size' => 5,
      '#maxlength' => 5,
      '#description' => t('The maximum size of all files a user can have on the site (in megabytes).'),
      '#field_suffix' => t('MB'),
    );
  }

  return system_settings_form($form);
}

/**
 * Get all BlogAPI information, optionally filtered by API type
 */
function blogapi_get_info($api_type = NULL) {
  // Invoke hook_blogapi_info().
  foreach (module_implements('blogapi_info') as $k => $module) {
    $info = module_invoke($module, 'blogapi_info');
    if ($info['api_version'] == 2) {
      $api_information[$module] = $info;
    }
  }

  // If we don't have an API type filter, then allow the info to be altered
  // and return it.
  if (is_null($api_type)) {
    drupal_alter('blogapi_info', $api_information);
    return $api_information;
  }

  // If we have a filter parameter, return filtered information instead.
  $filtered_api_info = array();
  foreach ($api_information as $name => $info) {
    if ($info['type'] == $api_type) {
      $filtered_api_info[$name] = $info;
    }
  }
  drupal_alter('blogapi_info', $filtered_api_info);
  return $filtered_api_info;
}

/**
 * Get a list of API types currently available to BlogAPI.
 */
function blogapi_get_api_types() {
  $apis = blogapi_get_info();
  $api_types = array();
  foreach ($apis as $info) {
    // Only include API types using the correct API version.
    if ($info['api_version'] == 2) {
      $api_types[$info['type']] = $info['type'];
    }
  }
  return $api_types;
}

/**
 * Implements hook_ctools_plugin_api().
 */
function blogapi_ctools_plugin_api() {
  list($module, $api) = func_get_args();
  if ($module == "services" && $api == "services") {
    return array("version" => "3");
  }
}

/**
 * Implements hook_default_services_endpoint().
 *
 * This function is enabling all resources by default, but that behavior
 * can be overridden via hook_blogapi_default_services_alter().
 */
function blogapi_default_services_endpoint() {
  $export = array();

  $api_types = blogapi_get_api_types();
  foreach ($api_types as $type) {
    $endpoint = new stdClass;
    $endpoint->disabled = FALSE;
    $endpoint->api_version = 3;
    $endpoint->name = 'blogapi_' . $type;
    $endpoint->server = $type . '_server';
    $endpoint->path = 'blogapi/' . $type;
    $endpoint->authentication = array();
    $endpoint->server_settings = '';

    // Get all resources for $type APIs
    $info = blogapi_get_info($type);
    $resources = array();
    foreach ($info as $module => $api_info) {
      $resources += module_invoke($module, 'services_resources');
    }

    $endpoint->resources = $resources;
    $endpoint->debug = 0;
    $export['blogapi_' . $type] = $endpoint;
  }

  drupal_alter('blogapi_default_services', $export);

  return $export;
}

/**
 * Prepare an error message to send to the client
 */
function blogapi_error($type, $message) {
  $blogapi_error_function = 'blogapi_' . $type. '_error';
  $blogapi_error_function($message);
}

/**
 * Prepare an error message for returning to the XMLRPC caller.
 */
function blogapi_xmlrpc_error($message) {
  static $xmlrpcusererr;

  if (!is_array($message)) {
    $message = array($message);
  }

  $message = implode(' ', $message);

  return xmlrpc_error($xmlrpcusererr + 1, strip_tags($message));
}

/**
 * Prepare an error message for returning to the REST caller.
 *
 * @todo: Write this function.
 */
function blogapi_rest_error($message) {

}
