<?php
/**
 * @file
 * Enable users to post using applications that support BlogAPIs.
 */

/**
 * Implements hook_permission().
 */
function blogapi_permission() {
  return array(
    'manage content with blogapi' => array(
      'title' => t('Manage content with BlogAPI'),
    ),
    'administer blogapi' => array(
      'title' => t('Administer BlogAPI settings'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function blogapi_menu() {
  $items = array();

  $items['blogapi/rsd'] = array(
    'title' => 'RSD',
    'page callback' => 'blogapi_rsd',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/services/blogapi'] = array(
    'title' => 'BlogAPI',
    'description' => 'Configure content types and file settings for external blogging clients.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('blogapi_admin_settings_form'),
    'access arguments' => array('administer blogapi'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Implements hook_init().
 */
function blogapi_init() {
  if (drupal_is_front_page()) {
    drupal_add_html_head_link(
      array(
        'rel' => 'EditURI',
        'type' => 'application/rsd+xml',
        'title' => t('RSD'),
        'href' => url('blogapi/rsd', array('absolute' => TRUE)),
      ),
      TRUE
    );
  }
}

/**
 * Ensure that a given user has permission to use BlogAPI
 */
function blogapi_validate_user($username, $password) {
  global $user;

  // Check the username and password.
  $uid = user_authenticate($username, $password);

  if (is_numeric($uid)) {
    $user = user_load($uid);
    if ($user->uid) {
      user_login_finalize();

      services_remove_user_data($user);

      if (user_access('manage content with blogapi', $user)) {
        // User has appropriate permissions.
        return $user;
      }
      else {
        return services_error(t('You do not have permission to edit this blog'), 405);
      }
    }
  }

  watchdog('user', 'Invalid login attempt for %username.', array('%username' => $username));

  return services_error(t('Invalid username or password'), 401);
}

/**
 * Return a BlogAPI RSD for XML-RPC APIs
 *
 * @todo: Implement apiLink correctly using service endpoint URL
 * @todo: Implement multi-user blogs
 */
function blogapi_rsd() {
  global $base_url;

  $base = url('', array('absolute' => TRUE));
  $xmlrpc_apis = blogapi_get_info('xmlrpc');
  $default_xmlrpc_api = variable_get('blogapi_xmlrpc_default_provider', NULL);
  // Until we figure out how to handle multiple bloggers, we'll just use a
  // hardcoded blogid.
  $blogid = 1;

  drupal_add_http_header('Content-Type', 'application/rsd+xml; charset=utf-8');

  // The extra whitespace in this function is to preserve code alignment in
  // the output.
  print <<<__RSD__
<?xml version="1.0"?>
<rsd version="1.0" xmlns="http://archipelago.phrasewise.com/rsd">
  <service>
    <engineName>Drupal</engineName>
    <engineLink>http://drupal.org/</engineLink>
    <homePageLink>{$base}</homePageLink>
    <apis>
__RSD__;

  foreach ($xmlrpc_apis as $module => $info) {
    $default = 'false';
    if ($module == $default_xmlrpc_api) {
      $default = 'true';
    }
    $endpoint = "{$base_url}/blogapi/{$info['type']}";
    print "\n      <api name='{$info['name']}' preferred='{$default}' apiLink='{$endpoint}' blogID='{$blogid}' />";
  }

  print <<<__RSD__

    </apis>
  </service>
</rsd>

__RSD__;

}

/**
 * BlogAPI admin settings form
 */
function blogapi_admin_settings_form() {
  $form = array();

  $form['settings_apis'] = array(
    '#type' => 'fieldset',
    '#title' => t('API configuration'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );

  // Default provider for each API.
  foreach (blogapi_get_api_types() as $type) {
    $providers = blogapi_get_info($type);
    $provider_options = array();
    foreach ($providers as $name => $provider) {
      $provider_options[$name] = $provider['name'];
    }

    $form['settings_apis']['blogapi_' . $type . '_default_provider'] = array(
      '#type' => 'radios',
      '#title' => t('Default provider for %type APIs', array('%type' => $type)),
      '#required' => TRUE,
      '#options' => $provider_options,
      '#default_value' => variable_get('blogapi_' . $type . '_default_provider', NULL),
      '#description' => t('Select the default provider for %type API clients. This may affect client configuration.', array('%type' => $type)),
    );
  }

  $form['settings_node_types'] = array(
    '#type' => 'fieldset',
    '#title' => t('Node types'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );

  // Set up BlogAPI node types.
  $node_types = array_map('check_plain', node_type_get_names());
  $defaults = isset($node_types['article']) ? array('article' => 'article'): array();
  $form['settings_node_types']['blogapi_node_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Enable for external blogging clients'),
    '#required' => TRUE,
    '#default_value' => variable_get('blogapi_node_types', $defaults),
    '#options' => $node_types,
    '#description' => t('Select the content types available to external blogging clients via Blog API. If supported, each enabled content type will be displayed as a separate "blog" by the external client.'),
  );

  // $form['settings_formats'] = array(
  //   '#type' => 'fieldset',
  //   '#title' => t('Text filters'),
  //   '#collapsible' => FALSE,
  //   '#collapsed' => FALSE,
  // );

  // $formats = filter_formats();
  // $format_list = array();
  // foreach ($formats as $format) {
  //   $format_list[$format->format] = $format->name;
  // }

  // $form['settings_formats']['blogapi_default_format'] = array(
  //   '#type' => 'select',
  //   '#title' => t('Choose the input format for remote posts'),
  //   '#required' => TRUE,
  //   '#default_value' => variable_get('blogapi_default_format', filter_fallback_format()),
  //   '#options' => $format_list,
  //   '#description' => t('The user posting must have permissions for this format, otherwise the standard (anonymous) format is used.')
  // );

  $file_handling = FALSE;
  foreach (blogapi_get_api_types() as $type) {
    $providers = blogapi_get_info($type);

    foreach ($providers as $provider) {
      if (isset($provider['provides_file_handling']) && $provider['provides_file_handling'] === TRUE) {
        $file_handling = TRUE;
        break;
      }
    }
    if ($file_handling == TRUE) {
      break;
    }
  }

  // Only display the file options if we have a module that provides file
  // handling.
  if ($file_handling) {
    $form['settings_files'] = array(
      '#type' => 'fieldset',
      '#title' => t('File settings'),
      '#collapsible' => FALSE,
      '#collapsed' => FALSE,
    );

    $blogapi_extensions_default = variable_get('blogapi_extensions_default', 'jpg jpeg gif png txt doc xls pdf ppt pps odt ods odp');
    $blogapi_uploadsize_default = variable_get('blogapi_uploadsize_default', 1);
    $blogapi_usersize_default = variable_get('blogapi_usersize_default', 1);

    $form['settings_files']['blogapi_extensions_default'] = array(
      '#type' => 'textfield',
      '#title' => t('Default permitted file extensions'),
      '#default_value' => $blogapi_extensions_default,
      '#maxlength' => 255,
      '#description' => t('Default extensions that users can upload. Separate extensions with a space and do not include the leading dot.'),
    );

    $form['settings_files']['blogapi_uploadsize_default'] = array(
      '#type' => 'textfield',
      '#title' => t('Default maximum file size per upload'),
      '#default_value' => $blogapi_uploadsize_default,
      '#size' => 5,
      '#maxlength' => 5,
      '#description' => t('The default maximum file size a user can upload.'),
      '#field_suffix' => t('MB'),
    );

    $form['settings_files']['blogapi_usersize_default'] = array(
      '#type' => 'textfield',
      '#title' => t('Default total file size per user'),
      '#default_value' => $blogapi_usersize_default,
      '#size' => 5,
      '#maxlength' => 5,
      '#description' => t('The default maximum size of all files a user can have on the site.'),
      '#field_suffix' => t('MB'),
    );

    $form['settings_files']['upload_max_size'] = array(
      '#prefix' => '<p>',
      '#value' => t('Your PHP settings limit the maximum file size per upload to %size.', array('%size' => format_size(file_upload_max_size()))),
      '#suffix' => '</p>',
    );

    $roles = user_roles(FALSE, 'manage content with blogapi');
    foreach ($roles as $rid => $role) {
      $form['settings_files']['settings_role_' . $rid] = array(
        '#type' => 'fieldset',
        '#title' => t('Settings for @role role', array('@role' => $role)),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
      );
      $form['settings_files']['settings_role_' . $rid]['blogapi_extensions_' . $rid] = array(
        '#type' => 'textfield',
        '#title' => t('Permitted file extensions'),
        '#default_value' => variable_get('blogapi_extensions_' . $rid, $blogapi_extensions_default),
        '#maxlength' => 255,
        '#description' => t('Extensions that users in this role can upload. Separate extensions with a space and do not include the leading dot.'),
      );
      $form['settings_files']['settings_role_' . $rid]['blogapi_uploadsize_' . $rid] = array(
        '#type' => 'textfield',
        '#title' => t('Maximum file size per upload'),
        '#default_value' => variable_get('blogapi_uploadsize_' . $rid, $blogapi_uploadsize_default),
        '#size' => 5,
        '#maxlength' => 5,
        '#description' => t('The maximum size of a file a user can upload (in megabytes).'),
        '#field_suffix' => t('MB'),
      );
      $form['settings_files']['settings_role_' . $rid]['blogapi_usersize_' . $rid] = array(
        '#type' => 'textfield',
        '#title' => t('Total file size per user'),
        '#default_value' => variable_get('blogapi_usersize_' . $rid, $blogapi_usersize_default),
        '#size' => 5,
        '#maxlength' => 5,
        '#description' => t('The maximum size of all files a user can have on the site (in megabytes).'),
        '#field_suffix' => t('MB'),
      );
    }
  }

  return system_settings_form($form);
}

/**
 * Get all BlogAPI information, optionally filtered by API type
 */
function blogapi_get_info($api_type = NULL) {
  // Invoke hook_blogapi_info().
  foreach (module_implements('blogapi_info') as $k => $module) {
    $info = module_invoke($module, 'blogapi_info');
    if ($info['api_version'] == 2) {
      $api_information[$module] = $info;
    }
  }

  // If we don't have an API type filter, then allow the info to be altered
  // and return it.
  if (is_null($api_type)) {
    drupal_alter('blogapi_info', $api_information);
    return $api_information;
  }

  // If we have a filter parameter, return filtered information instead.
  $filtered_api_info = array();
  foreach ($api_information as $name => $info) {
    if ($info['type'] == $api_type) {
      $filtered_api_info[$name] = $info;
    }
  }
  drupal_alter('blogapi_info', $filtered_api_info);
  return $filtered_api_info;
}

/**
 * Get a list of API types currently available to BlogAPI.
 */
function blogapi_get_api_types() {
  $apis = blogapi_get_info();
  $api_types = array();
  foreach ($apis as $info) {
    // Only include API types using the correct API version.
    if ($info['api_version'] == 2) {
      $api_types[$info['type']] = $info['type'];
    }
  }
  return $api_types;
}

/**
 * Implements hook_ctools_plugin_api().
 */
function blogapi_ctools_plugin_api() {
  list($module, $api) = func_get_args();
  if ($module == "services" && $api == "services") {
    return array("version" => "3");
  }
}

/**
 * Implements hook_default_services_endpoint().
 *
 * This function is enabling all resources by default, but that behavior
 * can be overridden via hook_blogapi_default_services_alter().
 */
function blogapi_default_services_endpoint() {
  $export = array();

  $api_types = blogapi_get_api_types();
  foreach ($api_types as $type) {
    $endpoint = new stdClass();
    $endpoint->disabled = FALSE;
    $endpoint->api_version = 3;
    $endpoint->name = 'blogapi_' . $type;
    $endpoint->server = $type . '_server';
    $endpoint->path = 'blogapi/' . $type;
    $endpoint->authentication = array();
    $endpoint->server_settings = '';

    // Get all resources for $type APIs.
    $info = blogapi_get_info($type);
    $resources = array();
    foreach ($info as $module => $api_info) {
      $resources += module_invoke($module, 'services_resources');
    }

    $endpoint->resources = $resources;
    $endpoint->debug = 0;
    $export['blogapi_' . $type] = $endpoint;
  }

  drupal_alter('blogapi_default_services', $export);

  return $export;
}

/**
 * Helper function. Returns the latest few nodes created by a given user.
 */
function blogapi_get_recent_posts($content_type, $user, $number_of_posts = NULL) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', $content_type)
    ->propertyCondition('uid', $user->uid)
    ->propertyOrderBy('created', 'DESC')
    ->addMetaData('account', user_load($user->uid))
    ->range(0, $number_of_posts);

  $result = $query->execute();

  if (isset($result['node'])) {
    $nodes = $result['node'];

    $blog_nids = array();
    foreach ($nodes as $node) {
      $blog_nids[] = $node->nid;
    }

    $blogs = node_load_multiple($blog_nids);
    return $blogs;
  }

  return array();
}

/**
 * Validate that a content type is configured to work with BlogAPI
 *
 * @param string $content_type
 *   The machine name of the content type to validate
 *
 * @return TRUE|array
 *   TRUE if the content type is configured for use with BlogAPI or
 *   an error array if not.
 */
function blogapi_validate_content_type($content_type) {
  $types = blogapi_get_node_types();
  if (in_array($content_type, $types, TRUE)) {
    return TRUE;
  }

  $error_data = array(
    'message' => t('BlogAPI is not configured to support the @type content type.', array('@type' => $content_type)),
    'error_code' => 403,
  );
  return $error_data;
}

/**
 * Helper function. Adds appropriate metadata to the XML-RPC return values.
 */
function blogapi_format_post_for_xmlrpc($node, $bodies = TRUE) {
  $xmlrpcval = array(
    'userid' => $node->name,
    'dateCreated' => xmlrpc_date($node->created),
    'title' => $node->title,
    'postid' => $node->nid,
    'link' => url('node/' . $node->nid, array('absolute' => TRUE)),
    'permaLink' => url('node/' . $node->nid, array('absolute' => TRUE)),
  );

  if ($bodies) {
    $body = !empty($node->body) ? $node->body[LANGUAGE_NONE][0]['value'] : '';
    $format = !empty($node->body) ? $node->body[LANGUAGE_NONE][0]['format'] : 0;

    if ($node->comment == 1) {
      $comment = 2;
    }
    elseif ($node->comment == 2) {
      $comment = 1;
    }

    $xmlrpcval['content'] = "<title>$node->title</title>$body";
    $xmlrpcval['description'] = $body;

    // Add MT specific fields.
    $xmlrpcval['mt_allow_comments'] = (int) $comment;
    $xmlrpcval['mt_convert_breaks'] = $format;
  }

  // Allow altering the XML-RPC response.
  drupal_alter('blogapi_xmlrpc_response', $xmlrpcval);

  return $xmlrpcval;
}

/**
 * Helper function. Find allowed taxonomy terms for a node type.
 */
function blogapi_validate_terms($node) {
  // We do a lot of heavy lifting here since taxonomy module doesn't have a
  // stand-alone validation function.
  if (module_exists('taxonomy')) {
    $found_terms = array();
    if (!empty($node->taxonomy)) {
      $term_list = array_unique($node->taxonomy);
      $terms = taxonomy_term_load_multiple($term_list, array('type' => $node->type));
      $found_terms = array();
      $found_count = 0;
      foreach ($terms as $term) {
        $found_terms[$term->vid][$term->tid] = $term->tid;
        $found_count++;
      }
      // If the counts don't match, some terms are invalid or not accessible to
      // this user.
      if (count($term_list) != $found_count) {
        $error_data = array(
          'message' => t('Invalid categories were submitted.'),
          'error_code' => 405,
        );
        return $error_data;
      }
    }
    // Look up all the vocabularies for this node type.
    $vocabularies = taxonomy_vocabulary_load_multiple(array(), array('type' => $node->type));
    // Check each vocabulary associated with this node type.
    foreach ($vocabularies as $vocabulary) {
      // Required vocabularies must have at least one term.
      if ($vocabulary->required && empty($found_terms[$vocabulary->vid])) {
        $error_data = array(
          'message' => t('A category from the @vocabulary_name vocabulary is required.', array('@vocabulary_name' => $vocabulary->name)),
          'error_code' => 403,
        );
        return $error_data;
      }
      // Vocabularies that don't allow multiple terms may have at most one.
      if (!($vocabulary->multiple) && (isset($found_terms[$vocabulary->vid]) && count($found_terms[$vocabulary->vid]) > 1)) {
        $error_data = array(
          'message' => t('You may only choose one category from the @vocabulary_name vocabulary.', array('@vocabulary_name' => $vocabulary->name)),
          'error_code' => 403,
        );
        return $error_data;
      }
    }
  }
  elseif (!empty($node->taxonomy)) {
    $error_data = array(
      'message' => t('Error saving categories. This feature is not available.'),
      'error_code' => 405,
    );
    return $error_data;
  }
  return TRUE;
}

/**
 * Helper function. Get BlogAPI node types.
 */
function blogapi_get_node_types() {
  $node_types = array_map('check_plain', node_type_get_names());
  $defaults = !empty($node_types['article']) ? array('article' => 'article'): array();
  $node_types = array_filter(variable_get('blogapi_node_types', $defaults));
  return $node_types;
}

/**
 * Check that the user has permission to save the node with the chosen status.
 */
function blogapi_status_error_check($node) {
  $node = (object) $node;
  $original_status = $node->status;
  $node_type_default = variable_get('node_options_' . $node->type, array('status', 'promote'));

  // If we don't have the 'administer nodes' permission and the status is
  // changing or for a new node the status is not the content type's default,
  // then return an error.
  if (!user_access('administer nodes') && (($node->status != $original_status) || (empty($node->nid) && $node->status != in_array('status', $node_type_default)))) {
    if ($node->status) {
      return services_error(t('You do not have permission to publish this type of post. Please save it as a draft instead.'), 403);
    }
    else {
      return services_error(t('You do not have permission to save this post as a draft. Please publish it instead.'), 403);
    }
  }
}

/**
 * Helper function. Return the amount of space used by a given user.
 */
function blogapi_space_used($uid) {
  return db_query('SELECT SUM(filesize) FROM {blogapi_files} f WHERE f.uid = :uid', array(':uid' => $uid))->fetchField();
}

/**
 * Service allback for metaWeblog.editPost
 */
function blogapi_edit_post($postid, $username, $password, $content, $publish) {
  // Validate the user.
  $user = blogapi_validate_user($username, $password);

  $old_node = node_load($postid);
  $new_node = new stdClass;

  if (!$old_node) {
    return services_error(t('Node @nid not found', array('@nid' => $postid)), 404);
  }
  // Let the teaser be re-generated.
  unset($old_node->teaser);

  if (!node_access('update', $old_node, $user)) {
    return services_error(t('You do not have permission to update this post.'), 403);
  }

  // Save the original status for validation of permissions.
  $new_node->status = $publish;
  $new_node->type = $old_node->type;
  // Support bloggerAPI
  $new_node->title = is_string($content) ? blogapi_blogger_extract_title($content) : $content['title'];
  $new_node->body[LANGUAGE_NONE][0]['value'] = is_string($content) ? blogapi_blogger_extract_body($content) : $content['description'];

  if (empty($content['date']) && user_access('administer nodes')) {
    $new_node->date = format_date($old_node->created, 'custom', 'Y-m-d H:i:s O');
  }

  if (function_exists('_blogapi_mt_extra')) {
    _blogapi_mt_extra($new_node, $content);
  }

  module_invoke_all('blogapi_node_edit', $new_node);

  blogapi_status_error_check($new_node);

  // Load the required includes for drupal_execute
  module_load_include('inc', 'node', 'node.pages');

  node_object_prepare($old_node);

  // Setup form_state.
  $form_state = array();
  $form_state['values'] = (array) $new_node;
  $form_state['values']['op'] = t('Save');
  $form_state['node'] = $old_node;

  drupal_form_submit($old_node->type . '_node_form', $form_state, $old_node);

  if ($errors = form_get_errors()) {
    return services_error(implode(" ", $errors), 406, array('form_errors' => $errors));
  }
  else {
    watchdog('content', '@type: updated %title using Blog API.', array('@type' => $old_node->type, '%title' => $new_node->title), WATCHDOG_NOTICE, l(t('view'), "node/$old_node->nid"));
    return TRUE;
  }
}

/**
 * Creates a new node. Utility function for backend modules.
 */
function blogapi_new_post($username, $password, $postdata) {
  // Validate the user.
  $user = blogapi_validate_user($username, $password);

  if (!node_access('create', $postdata['type'], $user)) {
    return services_error(t('You do not have permission to create this type of post.'), 403);
  }

  if (($error = blogapi_validate_content_type($postdata['type'])) !== TRUE) {
    // Return an error if not configured type.
    return services_error($error['message'], $error['error_code']);
  }

  // @todo make more beautiful reassigning
  // Get the node type defaults.
  $node_type_default = variable_get('node_options_' . $postdata['type'], array('status', 'promote'));
  $node = new stdClass();
  $node->type = $postdata['type'];
  $node->promote = in_array('promote', $node_type_default);
  $node->uid = $user->uid;
  $node->status = $postdata['status'];
  $node->name = $user->name;
  $node->title = $postdata['title'];
  $node->language = LANGUAGE_NONE;
  $node->body = array(
    LANGUAGE_NONE => array(
      array(
        'formata' => filter_default_format($user),
        'value' => $postdata['body'],
      )
    )
  );

  if (empty($postdata['date']) && user_access('administer nodes')) {
    $node->date = format_date(REQUEST_TIME, 'custom', 'Y-m-d H:i:s O');
  }

  module_invoke_all('blogapi_new_post', $node);
  blogapi_status_error_check($node);

  // Load the required includes for drupal_execute
  module_load_include('inc', 'node', 'node.pages');

  // Setup form_state
  $form_state = array();
  $form_state['values'] = (array) $node;
  $form_state['values']['op'] = t('Save');

  drupal_form_submit($node->type . '_node_form', $form_state, $node);

  if ($errors = form_get_errors()) {
    return services_error(implode(" ", $errors), 406, array('form_errors' => $errors));
  }
  else {
    watchdog('content', '@type: added %title using BlogAPI.', array('@type' => $node->type, '%title' => $node->title), WATCHDOG_NOTICE, l(t('view'), 'node/' . $form_state['nid']));
    return $form_state['nid'];
  }
}

/**
 * Get vocabularies which are available as taxonomy_term_reference field in given content type.
 */
function blogapi_get_vocabularies_per_content_type($type) {
  $vocabularies = array();

  foreach (field_info_fields() as $field) {
    if ($field['type'] == 'taxonomy_term_reference' && is_array($field['bundles']['node'])) {
      foreach ($field['bundles']['node'] as $content_type) {
        if ($content_type == $type) {
          foreach ($field['settings']['allowed_values'] as $value) {
            $vocabularies[] = $value['vocabulary'];
          }
        }
      }
    }
  }

  // Return only unique items, because bundle can have some taxonomy reference fields with the same vocabulary
  return array_unique($vocabularies);
}

/**
 * Get vocabularies which are available as taxonomy_term_reference field in given content type.
 */
function blogapi_get_node_taxonomy_term_fields($nid) {
  $fields = array();
  $node = node_load($nid);

  foreach (field_info_fields() as $field) {
    if ($field['type'] == 'taxonomy_term_reference' && is_array($field['bundles']['node'])
      && in_array($node->type, $field['bundles']['node'])) {
        $fields[] = $field['field_name'];
    }
  }

  return $fields;
}

/**
 * Service callback for metaWeblog.getCategories
 * @TODO simplify this callback if possible
 */
function blogapi_get_categories($blogid, $username, $password) {
  // Validate the user.
  blogapi_validate_user($username, $password);

  if (($error = blogapi_validate_content_type($blogid)) !== TRUE) {
    // Return an error if not configured type.
    return services_error($error['message'], $error['error_code']);
  }

  $categories = array();
  $vocabularies = blogapi_get_vocabularies_per_content_type($blogid);

  if (!empty($vocabularies)) {
    foreach ($vocabularies as $vocabulary_machine_name) {
      $vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_machine_name);
      $terms = taxonomy_get_tree($vocabulary->vid);
      foreach ($terms as $term) {
        $categories[] = array('categoryName' => $term->name, 'categoryId' => $term->tid);
      }
    }
  }

  return $categories;
}

/**
 * Service callback for metaWeblog.getCategories
 * @TODO simplify this callback if possible
 */
function blogapi_get_node_categories($postid, $username, $password) {
  // Validate the user.
  blogapi_validate_user($username, $password);

  $node = node_load($postid);

  if (!$node) {
    return services_error(t('Node @nid not found', array('@nid' => $postid)), 404);
  }

  if (!node_access('view', $node, $user) || !user_access('administer nodes')) {
    // User does not have permission to view the node.
    return services_error(t('You are not authorized to view post @postid', array('@postid' => $postid)), 403);
  }

  $taxonomy_fields = blogapi_get_node_taxonomy_term_fields($node->nid);
  $categories = array();

  if (!empty($taxonomy_fields)) {
    foreach ($taxonomy_fields as $field) {
      $terms = field_get_items('node', $node, $field);
      if (!empty($terms)) {
        foreach ($terms as $term) {
          $term = taxonomy_term_load($term['tid']);
          $categories[] = array('categoryName' => $term->name, 'categoryId' => $term->tid, 'isPrimary' => TRUE);
        }
      }
    }
  }

  return $categories;
}